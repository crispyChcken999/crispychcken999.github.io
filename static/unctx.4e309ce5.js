const t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof global?global:"undefined"!=typeof window?window:{},n="__unctx__",o=t[n]||(t[n]=function(t={}){const n={};return{get:(o,e={})=>(n[o]||(n[o]=function(t={}){let n,o=!1;const e=t=>{if(n&&n!==t)throw new Error("Context conflict")};let r;if(t.asyncContext){const n=t.AsyncLocalStorage||globalThis.AsyncLocalStorage;n&&(r=new n)}const s=()=>{if(r&&void 0===n){const t=r.getStore();if(void 0!==t)return t}return n};return{use:()=>{const t=s();if(void 0===t)throw new Error("Context is not available");return t},tryUse:()=>s(),set:(t,r)=>{r||e(t),n=t,o=!0},unset:()=>{n=void 0,o=!1},call:(t,c)=>{e(t),n=t;try{return r?r.run(t,c):c()}finally{o||(n=void 0)}},async callAsync(t,e){n=t;const s=()=>{n=t},i=()=>n===t?s:void 0;c.add(i);try{const c=r?r.run(t,e):e();return o||(n=void 0),await c}finally{c.delete(i)}}}}({...t,...e})),n[o],n[o])}}()),e=(t,n={})=>o.get(t,n),r="__unctx_async_handlers__",c=t[r]||(t[r]=new Set);function s(t){const n=[];for(const r of c){const t=r();t&&n.push(t)}const o=()=>{for(const t of n)t()};let e=t();return e&&"object"==typeof e&&"catch"in e&&(e=e.catch((t=>{throw o(),t}))),[e,o]}export{s as e,e as g};
